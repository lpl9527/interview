
1.ABA问题
	https://blog.csdn.net/weixin_42671172/article/details/108340791

2.幂等性
	https://blog.csdn.net/weixin_42671172/article/details/108347208

3.分布式锁
	https://blog.csdn.net/weixin_42671172/article/details/108348025

4.分布式事务
	https://blog.csdn.net/weixin_42671172/article/details/108353019

5.设计模式

6.HashMap
	https://blog.csdn.net/woshimaxiao1/article/details/83661464

	jdk1.7 Entry数组主干+链表
	jdk1.8 Entry数组主干+链表+红黑树（使用红黑树的目的是加快查询效率。链表长度大于等于8时，才会转为红黑树维护，因为链表的插入效率大于红黑树）
	
	HashMap是非线程安全的（当get时进行put会产生共享资源访问争抢，导致拿到的不是正确的结果）

	线程安全的ConcurrentHashMap：
		https://blog.csdn.net/woshimaxiao1/article/details/83901113

7.jvm

8.springmvc
	https://blog.csdn.net/a745233700/article/details/80963758

9.spring
	https://blog.csdn.net/a745233700/article/details/80959716

10.mybatis
	https://blog.csdn.net/a745233700/article/details/80977133

11.网络协议/IO
	OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
	TCP/IP模型：应用层（telnet、http、ftp、smtp等协议）、传输层（tcp、udp等协议）、网络层（ip协议等）、链路层。

	Linux内核IO模型：
		同步：
			阻塞IO（BIO）、非阻塞IO（NIO）、IO多路复用、信号驱动。
		异步：
			异步IO。
	telnet localhost 8080
	
	对称加密与非对称加密区别：
		https://blog.csdn.net/qq_29689487/article/details/81634057	

	http与https区别：
		https://www.cnblogs.com/wqhwe/p/5407468.html
	
12.java并发编程
	创建线程的三种方式，继承Thread类、实现Runnable接口、实现Callable接口。
	想要拿到线程执行的返回结果，可以实现Callable<T>接口，内部使用call()方法执行线程逻辑。

	start() 线程级别调用，线程开启
	run() 方法级别调用，线程逻辑运行

	线程池：	https://www.jianshu.com/p/125ccf0046f3
	线程池ThreadPoolExecutor工作原理：
		当一个并发任务提交给线程池，先判断核心线程池所有线程是否都在执行任务，如果不是，则创建一个线程
		执行刚提交的任务。如果核心线程池已满，判断线程阻塞队列是否已满，如果未满，则将任务存储在队列中。
		如果队列已满，判断最大线程池是否已满，如果未满则创建新的线程执行当前任务，否则按照线程池饱和策略进行处理。
	线程池构造参数说明：
		corePoolSize：表示核心线程池大小。
		maximumPoolSize：最大线程池大小。
		keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了核心线程池大小，并且线程空闲时间超过了
			线程存活时间，这些线程将会被销毁，这样尽可能降低系统资源消耗。
		unit：keepAlive时间单位。
		workQueue：用于保存任务的阻塞队列。分类：ArrayBlockingQueue，数组实现的有界阻塞队列。
			LinkedBlockingQueue，链表实现的有界阻塞队列。PriorityBlockingQueue，支持优先级的无解阻塞队列。
		threadFactory：创建线程的工厂类。
		handler：饱和策略。当阻塞队列已满并且线程均已开启，说明线程池已经处于饱和状态。
			分类：AbortPolicy：直接拒绝所有提价的任务，并抛出异常。CallerRunsPolicy：只用调用者所在的线程来执行任务。
			DiscardPolicy：不处理直接丢弃掉任务。DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。
	线程执行submit与execute的区别：
		可接收的任务类型：
			execute只能接收Runnable类型的任务。submit可以接收Runnable和Callable类型的任务。
		返回值：
			execute没有返回值。submit有返回值，通过返回的Future对象的get()方法获取线程执行结果。
		异常处理：
			execute可以对异常进行正常捕获。submit如果不使用get()方法获取返回结果，会吃掉异常。	

13.Kafka
	结构：
	zookeeper集群 --> 多个Kafka实例、消息服务代理broker（消息生产者Producer生产消息，消息消费者Consumer订阅消费消息）
		--> 消息分类主题Topic 
		--> 分区Partition（解决单个Topic对应文件的IO性能瓶颈，通过增加水平扩展，可以分布在broker集群中不同的服务器上。
			Kafka引入了分区多副本机制Replica，提升服务容灾能力，副本之间是“一主多从”的关系，leader副本负责读写请求，follower副本负责副本间消息同步。
			消息在到达分区时会被分配一个特定的偏移量offset，offset是消息在分区中的唯一标识，保证消息在分区内的顺序性，offset不跨越分区，就是说Kafka保证的是分区有序而不是主题有序。）

14.Zookeeper
	开源的分布式协调服务，具有四种类型的数据节点（Znode）：持久节点、临时节点、持久顺序节点（增加了由父节点维护的自增整数数字）、临时顺序节点。
	集群规则：2N+1，N>0。所以集群至少要有3个节点，且是单节点。
	应用场景：实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁、分布式队列。

15.Dubbo
	分布式治理的服务框架，解决各服务之间的依赖和调用关系（SOA面向服务的架构体系）。默认使用netty通信框架。Dubbo是基于NIO实现的非阻塞并行调用，客户端不需要
		启用多线程即可并行完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个Future对象。
	一般使用zookeeper作为注册中心。
	服务失效踢出是基于zookeeper的临时节点原理。

16.索引
	索引是排好序的数据结构，用于根据数据结构算法实现数据行的快速检索。
	常见数据结构：
		二叉树、红黑树、B Tree、B+Tree
		散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。

17.Redis
	支持的5种数据类型：string、list（底层双向链表）、set、zset（通过score排序）、hash。
	支持master-slave模式的数据备份。
	redis的所有单个操作都是原子性的，多个操作支持事务，也能控制操作的原子性。
	redis是单进程单线程的，利用队列技术将并发访问变为串行访问。
	一个字符串能存储的最大容量为512MB。
	redis的两种持久化方式：
		https://www.cnblogs.com/shizhengwen/p/9283973.html

		一、RDB：使用数据及快照的方式持久化数据，粒度较大。在某个时间点记录redis的所有键值对，将数据写入一个临时文件（dump.rdb）替换上次持久化的文件，加载数据库时恢复数据到内存。
		过程：fork一个进程，遍历hash table，利用copy on write，把整个dump.rdb保存下来。save、shutdown、slave命令会触发这个操作。
		优点：（1）容灾性好，持久化文件可以保存到安全的磁盘。（2）性能最大化，使用单独fork子进程完成持久化写操作，让主进程继续处理命令，保证IO最大化。
			（3）相对于较大的数据集，比AOF的启动效率更高。
		缺点：（1）缓存一致性较低，RDB方式是间隔一段时间进行内存数据持久化，如果在下一次持久化之前redis发生故障（或手动关闭），可能会造成数据丢失。

		二、AOF：把写操作指令，持续的写入aof文件中。
		优点：（1）缓存一致性高，每进行一次写操作就记录到aof文件中。
		缺点：（1）AOF文件相对较大，且恢复速度慢。
		选择的标准：如果愿意牺牲一些性能，换取更高的缓存一致性，则使用aof方式。
	常见的性能问题和解决方案：
		（1）Master最好不要写内存快照，写内存快照时save命令调度rdbSave函数会阻塞主线程的工作，当快照较大时对性能影响是非常大的，会间断性停止服务。
		（2）为了主从复制的速度和连接的稳定性，Master和Slave最好在一个局域网内。
		（3）尽量避免在压力比较大的主库上添加从。
	redis同步机制：
		redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到从节点，从节点
		接收完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到从节点进行重放就完成了同步过程。
	主从复制（redis sentinel），用于实现高可用，在master宕机时会自动将slave提升为主节点，继续提供服务。
	集群（redis cluster），用于实现扩展性，集群中各几点分配16384个哈希槽。在单个redis内存不足时，使用redis cluster进行分片存储。
	什么情况下集群不可用？集群中任一主节点不可用并且其没有相应从节点顶上，则整个集群就会不可用。
	集群中哈希槽的概念？redis集群中有16384个哈希槽，每个key通过CRC校验后对18384取模来决定放置在哪个哈希槽，集群中的每一个节点负责一部分哈希槽。
	redis事务相关的命令：
		multi、exec、discard、watch	
	如何将一些固定已知前缀的key全部找出来？使用keys指令扫描指定模式的key列表。由于redis是单线程的，keys操作会导致线程阻塞一段时间，线上服务会停顿，知道指令执行完毕，
		服务才会恢复。这个时候可以使用scan指定，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，可以在代码中进行手动去重。
	redis做异步队列怎么用？一般使用list结构作为队列，lpush入队生产消息，rpop出队消费消息（非阻塞模式）。当rpop没有消息时，适当sleep一会再重试。如果不用sleep，可以使用
		阻塞模式的消息队列，使用brpop出队，返回0表示处于阻塞状态。
	redis如何实现一对多消费？可以使用pub/sub发布订阅模式（chanel），实现1:N消息队列。
	redis如何实现延时队列？使用zset有序集合，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取n秒之前的数据轮询进行处理。
	redis如何实现分布式锁？使用setnx指令来争抢锁的同时设置过期时间，保证是一个原子性操作。使用del指令来释放锁，也要保证是原子操作。

18.MySQL
	mysql的5中引擎：ISAM、MyISAM、Heap、Merge、InnoDB。
	MyISAM和InnovationDB区别：
		MyISAM不支持事务，但是每次查询都是原子的。支持表级锁，每个操作都是对表加锁。一个MyISAM表对应三个文件：表结构文件、数据文件、索引文件。
			采用非聚集索引，索引文件的数据域指向数据文件的指针
		InnoDB支持事务（ACID特性），支持事务的四种隔离级别（解决事务并发问题，脏读、不可重复读、幻读）。支持行级锁和外键约束，可以支持写并发。
			https://blog.csdn.net/weixin_42671172/article/details/106849808
			主键索引采用聚集索引（索引的数据域存储数据文件本身）。辅索引的数据域存储主键的值，因此从辅索引中查找数据需要先从索引中查找到主键
			值，再访问主索引根据主键值查找数据文件。最好使用自增主键，防止维护B+树时结构的大调整。
	char和varchar的区别：char列长度固定为创建表时执行的长度，范围是1到255，当char被存储时，用空格填充到指定长度，检索char需要删除尾随空格。char的查询速度
		要比varchar快，因为还要对varchar进行语法分析，确定这个字段是多少位的。
		varchar是可变长度字符串，不管初始时预分配字段长度为多少，存储时长度与实际字符串长度一致。













