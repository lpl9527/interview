
1.ABA问题
	https://blog.csdn.net/weixin_42671172/article/details/108340791

2.幂等性
	https://blog.csdn.net/weixin_42671172/article/details/108347208

3.分布式锁
	https://blog.csdn.net/weixin_42671172/article/details/108348025

4.分布式事务
	https://blog.csdn.net/weixin_42671172/article/details/108353019

5.设计模式

6.HashMap
	https://blog.csdn.net/woshimaxiao1/article/details/83661464

	jdk1.7 Entry数组主干+链表
	jdk1.8 Entry数组主干+链表+红黑树（使用红黑树的目的是加快查询效率。链表长度大于等于8时，才会转为红黑树维护，因为链表的插入效率大于红黑树）
	
	HashMap是非线程安全的（当get时进行put会产生共享资源访问争抢，导致拿到的不是正确的结果）

	线程安全的ConcurrentHashMap：
		https://blog.csdn.net/woshimaxiao1/article/details/83901113
	有序的LinkedHashMap:
		https://blog.csdn.net/yinni11/article/details/88663713

7.jvm

8.springmvc
	https://blog.csdn.net/a745233700/article/details/80963758

9.spring
	https://blog.csdn.net/a745233700/article/details/80959716

10.mybatis
	https://blog.csdn.net/a745233700/article/details/80977133

11.网络协议/IO
	OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
	TCP/IP模型：应用层（telnet、http、ftp、smtp等协议）、传输层（tcp、udp等协议）、网络层（ip协议等）、链路层。

	Linux内核IO模型：
		同步：
			阻塞IO（BIO）、非阻塞IO（NIO）、IO多路复用、信号驱动。
		异步：
			异步IO。
	telnet localhost 8080
	
	对称加密与非对称加密区别：
		https://blog.csdn.net/qq_29689487/article/details/81634057	

	http与https区别：
		https://www.cnblogs.com/wqhwe/p/5407468.html
	
12.java并发编程
	创建线程的三种方式，继承Thread类、实现Runnable接口、实现Callable接口。
	想要拿到线程执行的返回结果，可以实现Callable<T>接口，内部使用call()方法执行线程逻辑。

	start() 线程级别调用，线程开启
	run() 方法级别调用，线程逻辑运行

	线程池：	https://www.jianshu.com/p/125ccf0046f3
	线程池ThreadPoolExecutor工作原理：
		当一个并发任务提交给线程池，先判断核心线程池所有线程是否都在执行任务，如果不是，则创建一个线程
		执行刚提交的任务。如果核心线程池已满，判断线程阻塞队列是否已满，如果未满，则将任务存储在队列中。
		如果队列已满，判断最大线程池是否已满，如果未满则创建新的线程执行当前任务，否则按照线程池饱和策略进行处理。
	线程池构造参数说明：
		corePoolSize：表示核心线程池大小。
		maximumPoolSize：最大线程池大小。
		keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了核心线程池大小，并且线程空闲时间超过了
			线程存活时间，这些线程将会被销毁，这样尽可能降低系统资源消耗。
		unit：keepAlive时间单位。
		workQueue：用于保存任务的阻塞队列。分类：ArrayBlockingQueue，数组实现的有界阻塞队列。
			LinkedBlockingQueue，链表实现的有界阻塞队列。PriorityBlockingQueue，支持优先级的无解阻塞队列。
		threadFactory：创建线程的工厂类。
		handler：饱和策略。当阻塞队列已满并且线程均已开启，说明线程池已经处于饱和状态。
			分类：AbortPolicy：直接拒绝所有提价的任务，并抛出异常。CallerRunsPolicy：只用调用者所在的线程来执行任务。
			DiscardPolicy：不处理直接丢弃掉任务。DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。
	线程执行submit与execute的区别：
		可接收的任务类型：
			execute只能接收Runnable类型的任务。submit可以接收Runnable和Callable类型的任务。
		返回值：
			execute没有返回值。submit有返回值，通过返回的Future对象的get()方法获取线程执行结果。
		异常处理：
			execute可以对异常进行正常捕获。submit如果不使用get()方法获取返回结果，会吃掉异常。	

13.Kafka
	结构：
	zookeeper集群 --> 多个Kafka实例、消息服务代理broker（消息生产者Producer生产消息，消息消费者Consumer订阅消费消息）
		--> 消息分类主题Topic 
		--> 分区Partition（解决单个Topic对应文件的IO性能瓶颈，通过增加水平扩展，可以分布在broker集群中不同的服务器上。
			Kafka引入了分区多副本机制Replica，提升服务容灾能力，副本之间是“一主多从”的关系，leader副本负责读写请求，follower副本负责副本间消息同步。
			消息在到达分区时会被分配一个特定的偏移量offset，offset是消息在分区中的唯一标识，保证消息在分区内的顺序性，offset不跨越分区，就是说Kafka保证的是分区有序而不是主题有序。）

14.Zookeeper
	开源的分布式协调服务，具有四种类型的数据节点（Znode）：持久节点、临时节点、持久顺序节点（增加了由父节点维护的自增整数数字）、临时顺序节点。
	集群规则：2N+1，N>0。所以集群至少要有3个节点，且是单节点。
	应用场景：实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁、分布式队列。

15.Dubbo
	分布式治理的服务框架，解决各服务之间的依赖和调用关系（SOA面向服务的架构体系）。默认使用netty通信框架。Dubbo是基于NIO实现的非阻塞并行调用，客户端不需要
		启用多线程即可并行完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个Future对象。
	一般使用zookeeper作为注册中心。
	服务失效踢出是基于zookeeper的临时节点原理。

16.索引
	索引是排好序的数据结构，用于根据数据结构算法实现数据行的快速检索。
	常见数据结构：
		https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
		二叉树：树状结构，右边子元素大于父元素。缺点：对于单边增长的数据插入就会退化为链表（查询效率低）。
		红黑树：在二叉树的基础上优化了单边数据插入时的问题（二叉平衡树），自动平衡优化结构为树结构。缺点：数据量大时树的深度很大。
		B Tree：优化了红黑树深度缺点。B Tree每个节点包含多个索引（索引左右也是多索引节点二叉树），从左到右递增排列。页节点具有相同的深度，叶节点的指针为空。所有索引元素不重复。节点中的数据索引从左到右递增排列。
		B+Tree：整体结构与B Tree类似。区别：非叶子节点不存储数据，只存储索引，节点可以放置更多索引（可进行更大的水平扩展，减少IO）。
				叶子节点之间用双向指针连接，提高了区间访问的性能（这也是mysql提倡自增主键的原因，也可提升索引字段范围查找性能）。
		散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。
		
		MySQL的MyISAM引擎索引文件和数据文件是分离的（非聚集）。B+Tree非聚集索引的叶子节点存储的数据是数据行地址的指针。
			InnoDB引擎的数据文件与索引文件不分离（聚集）。B+Tree聚集索引主键的叶子节点包含了索引所在行的所有字段数据。非主键字段的索引叶子节点只存储主键的值（节省空间），根据主键值再检索主键索引查找相应行记录。

	选择：
		B Tree索引：（1）适合高基数的字段（唯一值多）。（2）适合大量的增删改操作。	create index emp_dept_index on emp(dept_no) tablespace users;
		Bitmap(位图)索引：（1）适用于该列只有几个枚举的情况，如性别0，1。（2）更新代价很高。	create bitmap index emp_gender_index on emp(gender) tablesapce users;
17.Redis
	支持的5种数据类型：string、list（底层双向链表）、set、zset（通过score排序）、hash。
	支持master-slave模式的数据备份。
	redis的所有单个操作都是原子性的，多个操作支持事务，也能控制操作的原子性。
	redis是单进程单线程的，利用队列技术将并发访问变为串行访问。
	一个字符串能存储的最大容量为512MB。
	redis的两种持久化方式：
		https://www.cnblogs.com/shizhengwen/p/9283973.html

		一、RDB：使用数据及快照的方式持久化数据，粒度较大。在某个时间点记录redis的所有键值对，将数据写入一个临时文件（dump.rdb）替换上次持久化的文件，加载数据库时恢复数据到内存。
		过程：fork一个进程，遍历hash table，利用copy on write，把整个dump.rdb保存下来。save、shutdown、slave命令会触发这个操作。
		优点：（1）容灾性好，持久化文件可以保存到安全的磁盘。（2）性能最大化，使用单独fork子进程完成持久化写操作，让主进程继续处理命令，保证IO最大化。
			（3）相对于较大的数据集，比AOF的启动效率更高。
		缺点：（1）缓存一致性较低，RDB方式是间隔一段时间进行内存数据持久化，如果在下一次持久化之前redis发生故障（或手动关闭），可能会造成数据丢失。

		二、AOF：把写操作指令，持续的写入aof文件中。
		优点：（1）缓存一致性高，每进行一次写操作就记录到aof文件中。
		缺点：（1）AOF文件相对较大，且恢复速度慢。
		选择的标准：如果愿意牺牲一些性能，换取更高的缓存一致性，则使用aof方式。
	常见的性能问题和解决方案：
		（1）Master最好不要写内存快照，写内存快照时save命令调度rdbSave函数会阻塞主线程的工作，当快照较大时对性能影响是非常大的，会间断性停止服务。
		（2）为了主从复制的速度和连接的稳定性，Master和Slave最好在一个局域网内。
		（3）尽量避免在压力比较大的主库上添加从。
	redis同步机制：
		redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到从节点，从节点
		接收完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到从节点进行重放就完成了同步过程。
	主从复制（redis sentinel），用于实现高可用，在master宕机时会自动将slave提升为主节点，继续提供服务。
	集群（redis cluster），用于实现扩展性，集群中各几点分配16384个哈希槽。在单个redis内存不足时，使用redis cluster进行分片存储。
	什么情况下集群不可用？集群中任一主节点不可用并且其没有相应从节点顶上，则整个集群就会不可用。
	集群中哈希槽的概念？redis集群中有16384个哈希槽，每个key通过CRC校验后对18384取模来决定放置在哪个哈希槽，集群中的每一个节点负责一部分哈希槽。
	redis事务相关的命令：
		multi、exec、discard、watch	
	如何将一些固定已知前缀的key全部找出来？使用keys指令扫描指定模式的key列表。由于redis是单线程的，keys操作会导致线程阻塞一段时间，线上服务会停顿，知道指令执行完毕，
		服务才会恢复。这个时候可以使用scan指定，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，可以在代码中进行手动去重。
	redis做异步队列怎么用？一般使用list结构作为队列，lpush入队生产消息，rpop出队消费消息（非阻塞模式）。当rpop没有消息时，适当sleep一会再重试。如果不用sleep，可以使用
		阻塞模式的消息队列，使用brpop出队，返回0表示处于阻塞状态。
	redis如何实现一对多消费？可以使用pub/sub发布订阅模式（chanel），实现1:N消息队列。
	redis如何实现延时队列？使用zset有序集合，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取n秒之前的数据轮询进行处理。
	redis如何实现分布式锁？使用setnx指令来争抢锁的同时设置过期时间，保证是一个原子性操作。使用del指令来释放锁，也要保证是原子操作。

18.MySQL
	mysql的5中引擎：ISAM、MyISAM、Heap、Merge、InnoDB。
	MyISAM和InnovationDB区别：
		MyISAM不支持事务，但是每次查询都是原子的。支持表级锁，每个操作都是对表加锁。一个MyISAM表对应三个文件：表结构文件、数据文件、索引文件。
			采用非聚集索引，索引文件的数据域指向数据文件的指针。
		InnoDB支持事务（ACID特性），支持事务的四种隔离级别（解决事务并发问题，脏读、不可重复读、幻读）。支持行级锁和外键约束，可以支持写并发。
			https://blog.csdn.net/weixin_42671172/article/details/106849808
			主键索引采用聚集索引（索引的数据域存储数据文件本身）。辅索引的数据域存储主键的值，因此从辅索引中查找数据需要先从索引中查找到主键
			值，再访问主索引根据主键值查找数据文件。最好使用自增主键，防止维护B+树时结构的大调整。
	char和varchar的区别：char列长度固定为创建表时执行的长度，范围是1到255，当char被存储时，用空格填充到指定长度，检索char需要删除尾随空格。char的查询速度
		要比varchar快，因为还要对varchar进行语法分析，确定这个字段是多少位的。
		varchar是可变长度字符串，不管初始时预分配字段长度为多少，存储时长度与实际字符串长度一致。
	BLOB和TEXT区别：
		BLOB是一个二进制对象，可以容纳可变数量的数据，区分大小写。而TEXT不区分大小写。
	分页查询：select * from table_name where limit 10,30;
	now()函数和current_date()区别：now()显示当前年份，精确到秒。current_date()显示年份精确到日。
	mysql中非标准字符串类型：tinytext、text、mediumtext、longtext。
	mysql支持事务吗？在InnoDB引擎下关闭自动提交，使用set autocommit = 0，就需要我们手动提交或回滚更改的操作。
	优化相关：（1）设计良好的数据结构，允许部分数据冗余，尽量避免连接查询。（2）选择合适的存储引擎和表字段类型，适当的添加索引。
		（3）数据库主从读写分离（主库负责写，从库负责读）https://blog.csdn.net/why15732625998/article/details/80463041。
		（4）按规律分表，减少单表数据量提高查询速度。（5）添加缓存机制。（6）编写执行效率较高的sql。
	什么情况下设置了索引但无法使用？（1）对于like语句，以"%"或者"_"开头不会使用索引，结尾会使用索引。（2）or的前后没有同时使用索引。
	建立索引的原则：（1）在频繁使用的、对于缩小查询范围有很大帮助的字段建立索引。（2）在需要排序的字段上建立索引。
	什么情况下不适合建索引？（1）查询中很少涉及的列或重复值比较多的列不宜建立索引。（2）特殊的数据类型不宜建立索引，如text等。

19.并发编程
	进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位。一个程序最少一个进程，一个进程最少一个线程。
	什么是线程的上下文切换？多线程会共同使用计算机上的一组CPU，而线程数大于给程序分配的CPU数量时，为了使各个线程都有执行的机会，就需要切换使用CPU资源，就是线程的上下文切换。
	为什么使用Executor线程池？每次执行任务创建单个线程new Thread()是比较耗时、耗资源的，而且缺乏管理（定时定期执行不便实现），可以被无限制的创建，线程之间的相互竞争会导致过
		多占用系统资源而导致系统的瘫痪。
	Executors是创建线程池的工具类。Executor接口用于执行线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法操作线程池。
		使用ThreadPoolExecutor可以创建自定义线程池。Future对表示异步处理的结果，提供了检查处理是否完成的方法，并使用get()方法获取线程执行结果。
	什么是原子操作？原子操作意为不可中断的一个或一系列操作，是一个不受其它操作影响的操作任务单元。原子操作是多线程环境下避免数据不一致的必要手段。i++并不是一个原子操作。
	常见的原子类：java.util.current包下提供了一组原子类，其基本特性就是在多线程环境下，当有多个线程同时执行这些类的方法时，具有排他性。即当某个线程进入方法，执行其中的
			指令时，不会被其它线程打断，别的线程就像自旋锁一样，一直等到该方法执行完成。原子类：AutomicBoolean、AtomicInteger、AtomicReference。
			原子数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。
			解决ABA问题的原子类：AtomicMarkableReference（通过引入boolean来反映有没有被改变过）、AtomicStampedReference（通过引入int累加来反映有没有被改变过）。
	Lock接口是什么？Lock接口是Synchronized的扩展版，比同步方法和同步块提供了更具扩展性的锁操作。
	线程的5种状态：
		新建状态（New）：用new 语句新建的线程处于新建状态，此时它和其它Java对象一样，仅在对中被分配了内存。
		就绪状态（Runnable）：当一个线程对象被创建后，其它线程调用start()方法，该线程就处于就绪状态。Java虚拟机为它创建方法调用栈和程序计数器。
			处于这个状态的线程位于可运行池中，等待CPU的使用权。
		运行状态（Running）：线程占用CPU，执行程序代码，只有处于就绪状态的线程才能转为运行状态。
		阻塞状态（Blocked）：阻塞状态是线程因为某些原因放弃CPU，暂时停止运行。线程处于阻塞状态时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转为运行状态。
		死亡状态（Dead）：当线程退出run()方法时，就进入死亡状态，该线程结束生命周期。
	volatile作用？保证内存可见性（当线程修改了主内存变量其它线程可以感知到）和禁止指令重排，但它不能保证原子性。
	wait()、yield()和sleep()方法的不同？最大的不同是在等待时wait会释放锁，而sleep会一直持有锁。wait通常用于线程交互，sleep通常用于暂停执行。wait方法会释放cpu执行权和
		占有的锁。sleep方法仅释放cpu使用权，锁仍然占用。线程被放入超时等待队列，与yield相比，它使线程较长时间得不到执行。yield方法仅释放cpu使用权，锁仍然占用，线程会
		被放入就绪队列，会在短时间内再次执行。
	直接调用线程的run()方法只是在当前线程中执行该方法，相当于调用普通方法，想要在线程中执行需要调用Thread.start()。
	并发编程三要素：（1）原子性，是指一个或多个操作，要么全部执行并且在执行的过程中不被其它操作打断，要么全部不执行。
			（2）可见性，指多个线程对变量进行修改后，其它线程可以立即看到修改的结果。（3）有序性，即程序的执行顺序按照代码的先后顺序来执行。
	实现可见性的方式？synchronized或者Lock，保证同一时刻只有一个线程获取锁执行代码，锁释放之后将最新的值刷新到主内存，其它线程可见。
			









