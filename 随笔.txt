
1.ABA问题
	https://blog.csdn.net/weixin_42671172/article/details/108340791

2.幂等性
	https://blog.csdn.net/weixin_42671172/article/details/108347208

3.分布式锁
	https://blog.csdn.net/weixin_42671172/article/details/108348025

4.分布式事务
	https://blog.csdn.net/weixin_42671172/article/details/108353019
	2PC（两阶段提交协议），遵循XA规范，框架实现有atomikos。是资源层面的分布式事务，对操作涉及的整个系统资源加锁，保证了强一致性，在两阶段提交的整个过程中，会一直持有资源的锁，高并发环境下性能很差。
	TCC（柔性事务），是业务层面的分布式事务，保证最终一致性，不会一直持有资源的锁，锁力度较小（仅涉及每个业务系统的单个API操作的资源锁），会立即提交，通过业务代码来实现事务。

5.设计模式
	参考代码: https://github.com/lpl9527/design_patterns
	
	单例模式（Singleton）：保证一个类只有一个实例，并且提供一个获取该实例的全局访问点。场景：重量级对象，不需要多个实例：如线程池、数据库连接池。Spring容器中的Bean默认就是单例。
		懒汉式:延迟加载，只有在真正使用时才进行初始化。多线程下存在线程安全问题，可以使用双检查（if null == obj）加锁（synchronized）+ volatile修饰防止new对象时指令重排序 解决。
		饿汉式：类加载的实例化阶段就进行了实例的初始化。本质上借助于JVM的类加载机制，保证单线程及多线程环境下实例的唯一性，不存在线程安全问题。
		静态内部类方式：懒加载的一种形式，只有真正使用时才会触发类的初始化。利用类加载机制保证线程安全。
		
 	代理模式（Proxy）：代理设计模式提供了对目标对象（即被代理对象）的另外的访问方式，及通过代理对象访问目标对象。优点：可以在目标对象实现的基础上，扩展
		目标对象的功能，符合软件设计的开（开出代理对象供我们使用）闭（关闭对被代理对象的直接访问）原则（即在对既有代码不改动的情况下进行功能的扩展）。特点
		是：我们直接使用的是代理对象，由代理对象去调用目标对象。
		静态代理：
			静态代理在使用时，需要定义接口或者父类，被代理对象和代理对象需要一起实现该接口或者继承此父类。
			缺点：由于代理对象需要与目标对象实现一样的接口，一旦增加接口或者接口增加方法，目标对象和代理对象都要维护。
		动态代理：
			解决静态代理的缺陷可以使用动态代理，动态代理的特点：代理对象不需要实现接口或继承类。
			分类：
				JDK基于接口的动态代理：目标对象一定要实现接口，否则不能实现JDK动态代理，在程序运行时JVM才会为目标对象生成代理对象。
				CGLIB基于子类的动态代理：创建目标对象的子类作为代理对象。代理对象不能使用final修饰。
					如果目标对象的方法为final或static修饰，则不能对方法进行增强。例如：有些方法的事务不生效的场景可能就是使用了final或static修饰了方法。
		
		在Spring的AOP中，如果加入容器的目标对象实现了接口，则使用JDK动态代理，否则使用CGLIB动态代理。

6.HashMap
	https://blog.csdn.net/woshimaxiao1/article/details/83661464

	jdk1.7 Entry数组主干+链表
	jdk1.8 Entry数组主干+链表+红黑树（使用红黑树的目的是加快查询效率。链表长度大于等于8（哈希碰撞较大）时，才会转为红黑树维护，因为链表的插入效率大于红黑树）
	
	HashMap是非线程安全的（当get时进行put会产生共享资源访问争抢，导致拿到的不是正确的结果）

	线程安全的ConcurrentHashMap：
		https://blog.csdn.net/woshimaxiao1/article/details/83901113
		并发度默认为16，也就是segment的大小。
	有序的LinkedHashMap:
		https://blog.csdn.net/yinni11/article/details/88663713

7.jvm
	https://blog.csdn.net/qq_41701956/article/details/100074023
	Java虚拟机组成：类装载子系统、运行时数据区、字节码执行引擎（操作数据区，执行字节码指令）。https://www.cnblogs.com/czwbig/p/11127124.html
		查看Java字节码指令文件，可以在字节码文件目录下使用命令，例如：javap -c User.class > User.txt
		
	Java内存模型（运行时数据区）组成：堆、栈、方法区（元空间）、本地方法栈、程序计数器。	https://www.cnblogs.com/rainple/p/10765752.html
		栈（线程栈）：线程私有，Java虚拟机会为每个线程分配一个栈内存区域，栈中又会为线程执行的每个方法分配一个独立的内存区域（方法栈帧，FILO先进后出），
			方法执行过后对应的方法栈帧的内存区域也将会被销毁（出栈）。方法栈帧内的组成：局部变量表（放置方法内的局部变量，如果变量是对象类型，放置的是对象
			在堆中的内存地址指针）、操作数栈（放置方法执行中的操作数）、动态链接、方法出口（放置调用此方法的线程的执行位置，用于退出方法时查找上层代码的执行位置）。
			
		堆：线程共享，分为年轻代、老年代。
			年轻代：默认约占1/3。又分为Eden（伊甸园区）、From Survivor、To Survivor。
				Eden，约占年轻代8/10，新创建的对象放在伊甸园区。
				From Survivor，约占年轻代1/10。
				To Survivor，约占年轻代1/10。
			老年代，默认约占2/3。
		方法区：线程共享，也称元空间、持久代。占用的是本地内存，不再占用虚拟机内存。放置常量（如字符串常量）、静态变量（如果静态变量是对象类型，则放置的是对象的内存地址的指针）、类信息。
		本地方法栈，线程私有，存放本地方法（一般是C语言实现），比如Thread类的start()方法。
		程序计数器：线程私有，记录当前线程正在运行的JVM指令码的位置（行号），是每个线程独有的。当线程上下文切换时，用于找到之前线程的执行位置。

		栈空间用光会触发StackOverFlowError，堆空间和常量池空间不足会触发OutOfMemoryError。String str = new String("abc"); 这个语句中str变量放置在栈中，new创建出来的字符串对象放在
			堆中，而"abc"字符串常量是放在方法区的。
			
	垃圾对象：（可达性分析算法）未被gc root引用的对象。所谓GC Roots根对象即为垃圾回收的进行垃圾判断的根对象节点，包括：线程栈的本地变量、静态变量（存放于方法区）、本地方法栈的变量等。将"GC Roots"对象作为
		起点，从这些节点开始向下搜索引用的对象，找到的对象都为非垃圾对象，其余未标记的对象都是垃圾对象。
	GC（垃圾收集）：
		字节码执行引擎开出的一个后台线程进行垃圾回收。
		当Eden区对象放满时会触发minor gc，清理掉Eden区中的垃圾对象，将非垃圾对象复制到From Survivor区，此时将对象对象头中的
			分代年龄加1。当第二次Eden区满时，minor gc会将Form Survivor区中的垃圾对象一起收集清理，非垃圾对象复制到To Survivor区，对象的分代年龄又会加1。当第三次Eden区满时，minor gc会
			将Eden区和To Survivor区中的垃圾对象一起收集清理，非垃圾对象复制到From Survivor区，分代年龄又会加1。以此类推...。当对象的分代年龄加到15（可设置）时，会将此对象复制到老年
			代（例如静态对象、线程池中的对象、spring容器中的对象）。
		当老年代被放满时，不会马上OOM，而是触发full gc，对整个堆中的对象进行垃圾回收。此过程会进行STW，即为Stop-The-World，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂
			起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互，这些现象多半是由于gc引起。当没有垃圾对象清理释放
			内存空间，又有新的对象创建时，就会产生OOM。
		我们可以使用jdk自带的工具查看jvm对象分配过程，命令行使用命令 jvisualvm。其中需要安装Visual GC插件。https://blog.csdn.net/shuai825644975/article/details/78970371
		
		所以我们进行JVM调优，优先就是减少full gc次数。
		案例：一个亿级流量（每日点击次数）的订单系统，假设每人点击二三十次，相当于日活用户500万，付费转化率为10%，相当于日均50万单，
			大促活动订单在几分钟产生，大概每秒1000多单，如果集群有3台机器处理，每天机器大概300单。假设每个订单对象大小大概1KB，加上操作的其它对象，放大20倍，再加上其它业务操作，再
			放大10倍，相当于每秒产生60MB的对象，这些对象可能在1秒钟之后就会变为垃圾对象（下单操作完成）。
			假设有一台8GB内存的主机，凭经验设置JVM内存参数为：
				java -Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar
			此时Eden区大小大概为800M，大概在13秒钟被放满，进行minor gc时其余12秒产生的对象都已变为了垃圾对象被清理掉，第13秒产生的对象会被放到From Survivor区，而实际上根据对象动态
			年龄判断规则，当一批对象的总大小大于这块Survivor区大小的50%时（此时Survivor区大小大概为100M），这些对象就会直接进入到老年代，这样老年代几分钟就会被放满，从而触发full gc，针对
			这种情况进行优化，不能将这批对象直接挪到老年代。参数中增加设置年轻代大小，如下：
				java -Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar
	判断对象存活算法：
		引用计数法：给每个对象添加一个引用计数器，每当有其它对象引用时，计数器就加1，引用失效时计数器减1，当该对象的引用计数为0的时候，则判定该对象可以被回收了。没有
			被Java采用，因为它没有解决对象的相互循环引用问题。
		可达性分析算法：Java垃圾回收采用的算法，通过一系列的”GC Roots“对象作为起始节点集，从这些对象开始根据引用关系向下搜索（路径称为“引用链”），如果某个对象没有与
			任何引用链相连（不可达），则认为此对象没有被使用。
			固定作为”GC Roots“对象包括：
				（1）Java虚拟机栈中的局部变量表中如局部变量、临时变量引用的对象。（2）方法区中的引用类型静态变量、常量引用的对象。（3）本地方法栈中JNI引用的对象。
	对象引用的四种状态：
		强引用：直接new出来的对象。
		软引用：在系统将要发生内存溢出的时候，虚拟机会尝试从这部分的引用类型中进行二次回收，如果二次回收后的内存仍不够用才会抛出内存溢出异常。Java中的类SoftReference表示软引用。
		弱引用：被弱引用关联的对象只能生存到下一次回收之前，在垃圾收集器工作之后，无论内存是否够用，这类的对象都会被回收掉。Java中的类WeakReference表示弱引用。
		虚引用：被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。
	
	分代收集理论：将Java堆划分出不同的区域，然后将回收对象根据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域中存储。
		如果一个区域（年轻代）中大多数对象都是朝生夕灭，难以熬过垃圾收集的话，那么把它们集中放在一起，每次回收只需保留少量存活对象而不需要去关注大量要被回收的对象，就能以较低的
		代价回收掉大量的内存空间。如果剩下的都是难以消亡的对象，把它们放到一块，虚拟机就可以以较低的频率来回收这个区域（老年代），这就兼顾了垃圾收集的时间开销和空间的有效利用。
	回收类型的划分：
		部分收集（Partial GC）:不完整收集整个Java堆。分为：
			新生代收集（Minor GC/Yong GC）：只进行新生代区域的垃圾收集。
			老年代收集（Major GC/Old GC）：只进行老年代的垃圾收集。
			混合收集（Mixed GC）：进行整个新生代和部分老年代的垃圾收集。
		整堆收集（Full GC）：进行整个方法堆和方法区的垃圾收集。
	
	垃圾收集算法：
		标记-清除算法：最基础的收集算法，分为“标记”和”清除“两个阶段，首先标记出所有要清除的对象，标记完成后，统一回收掉所有被标记的对象。也可以反过来，标记非垃圾对象，统一
			回收所有未被标记的对象。
			主要有两个缺点：
				（1）执行效率不稳定，如果堆中包含大量对象，而且其中大部分是需要回收的，这时必须进行大量的标记与清除工作。
				（2）内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存
					而不得不提前触发另一次垃圾收集动作。
		标记-复制算法：为了解决标记-清除算法在有大量可回收对象的执行效率低的问题，现在的大多数Java商用虚拟机都采用这种算法回收新生代。它是一种“半区复制”的垃圾收集算法，它
			将内存按容量划分为大小相等的两块，每次只用其中一块进行垃圾回收，当回收完毕将存活的对象一次性复制到另一块内存上面，然后进行垃圾回收的那一块内存空间一次性释放掉。
			缺点：
				（1）如果内存中多数对象都是存活的，这种算法将会产生大量的内存复制开销；
				（2）将内存空间缩小到了原来的一半；
			优点：
				（1）每次都是针对整个半区进行回收，因此不用考虑产生较多空间碎片的复杂情况；
			改进：IBM研究表明新生代中有98%（非绝对）的对象熬不过第一轮垃圾收集，因此不需要按照1:1比例进行内存划分。HotSpot虚拟机的Serial、ParNew等新生代垃圾收集器均采用了、
				半区复制分代策略来设计新生代的内存布局。做法是：将新生代分为一块较大的Eden区和两块较小的Survivor区（8:1:1，即每次新生代可用内存空间为整个新生代空间的90%），
				每次分配内存时只是用Eden区和其中一块Survivor区。当进行垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已
				用过的那块Survivor空间。
				当然，不可能保证每次回收都只有不多于10%的对象存活，因此还有一个“逃生门”的安全设计，当Survivor空间不足以容纳一次Monor GC后存活的对象，就需要依赖老年代的
				内存区域担保，这些对象将一次性进入老年代。
		标记-整理算法：标记-复制算法不适用于老年代的垃圾收集，针对老年的对象存亡特征，标记-整理算法与标记-清除算法的标记过程相同，但后续不是直接对对象进行回收清理，而是让
			所有存活的对象都向内存空间一端移动，直接清理掉边界以外的内存。
			缺点：
				（1）如果移动存活对象，在老年代这个每次回收都有大量存活对象存在的区域移动存活对象并更新所有对象的引用是一个极为负重的操作，这种操作必须要全程暂停用户程序
					才能进行，称为“Stop The World”。
			优点：不会产生空间碎片化问题。
			折中的方法是多数情况下使用标记-清除算法，当产生较多的内存空间碎片后再使用标记-整理算法进行回收。
		分代收集算法：
			将heap区划分为新生代和老年代，新生代又分为Eden和两个Survivor（比例8:1:1）。新生代垃圾收集为Minor GC，老年代为Major GC。整个堆回收为Full GC。
			Minor GC触发条件：创建新对象时Eden内存空间小于对象的大小。
			Major GC触发条件：（1）显式调用System.gc()方法；（2）老年代空间不足；（3）方法区空间不足；（4）新生代进入老年代的对象大小大于老年代剩余空间大小。
			
			Eden区的对象生命周期短，存活率低，因此采用复制算法实现，不同于一般的标记-复制算法，Eden的回收算法也叫停止-复制算法，当Eden区满时，清理垃圾对象，然后将存活对象
				复制到Survivor1区，清理掉Survivor0区，下次回收Eden区和Survivor1区，清理掉垃圾对象后将存活对象复制到Survivor0区，以此类推...。如果幸存者区的空间小于复制对象
				大小时，会将这一批对象直接移入老年代中。每发生一次Minor gc时，存活下来的对象的分代年龄则会加1，达到一定的年龄后（默认为15）该对象就会进入到老年代中。
				老年代的对象基本是经过多次Minor gc后存活下来的，因此他们都是比较稳定的，存活率高，如果还是用复制算法显然是行不通的。所以老年代使用“标记-整理”算法来回收
				对象的，从而提高老年代回收效率。
	
	经典垃圾收集器：
		先说两个概念：
			并行（Parallel）：描述的是多条垃圾收集线程之间的关系，同一时间有多条这样的线程在工作，此时用户线程处于等待状态。
			并发（Concurrent）：描述的是垃圾收集器线程与用户线程之间的关系，同一时间收集线程与用户线程在同时运行。
		
		Serial收集器：HotSpot虚拟机的新生代垃圾收集器，是一个单线程工作（只使用一个处理器或一个垃圾收集线程进行垃圾收集）的垃圾收集器，它在进行垃圾收集时，必须暂停其它所有工作
			线程，直至收集结束，会产生STW。
			收集过程：
				多个CPU（用户线程）进行工作 --> 单个GC线程（采用Serial收集器的复制算法进行新生代的垃圾回收，暂停所有用户线程） --> 
					单个GC线程（采用Serial Old收集器的标记-整理算法进行新生代的垃圾回收，暂停所有用户线程） --> 用户线程继续工作
			它仍然是HotSpot虚拟机在客户端模式下的新生代收集器，对于内存资源受限的收集器，它的内存消耗最小。由于没有线程交互的开销，它具有最高的单线程收集效率。适合桌面应用及
				微服务应用。
		
		ParNew收集器：实际上是Serial的多线程并行版本，使用多条线程进行新生代的垃圾收集。它是除了Serial之外唯一能与CMS收集器配合工作的收集器。ParNew是
			激活（?使用-XX:+UseConcMarkSweepGC选项）CMS后的默认新生代收集器。也可以?用-XX：+/-UseParNewGC选项来强制指定或者禁用它。---已退出历史舞台。
			收集过程：
				多个CPU（用户线程）进行工作 --> 多个GC线程并行工作（采用ParNew收集器的复制算法进行新生代的垃圾回收，暂停所有用户线程） --> 
					多个GC线程并行工作（采用Serial Old收集器的标记-整理算法进行新生代的垃圾回收，暂停所有用户线程） --> 用户线程继续工作
		
		Parallel Scavenge收集器：吞吐量优先收集器，也是基于标记-复制算法实现的新生代收集器，也是能够进行并行收集的多线程垃圾收集器。与ParNew不同的时，它的关注点不是尽可能缩短垃圾收集时用户
			线程的停顿时间，而是尽可能达到一个可控制的吞吐量（即处理器运行用户代码的时间 / 运行用户代码的时间+运行垃圾收集时间，例如：虚拟机完成某个任务耗费了100分钟
			，其中垃圾收集花掉1分钟，那么吞吐量就是100-1/100=99%）。停顿时间越短越适合需要与用户交互、保证服务质量的程序。而高吞吐量则可以高效率地利用服务器资源，尽快完成运算
			任务，适合在后台计算而不需要太多交互的分析任务。
			
			Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是：
				-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，大于0的毫秒数，收集器尽力保证垃圾收集时间不超过此值。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。
				-XX:GCTimeRatio：直接设置吞吐量大小，大于0小于100的整数，为吞吐量的倒数。
			还有一个参数值关注：-XX:+UseAdaptiveSizePolicy,开关参数，激活后不需要我们制定新生代等大小，只需制定基本参数-Xmx，虚拟机会动态监控分配。
			
		Serail Old收集器：是Serial的老年代版本，基于标记-整理算法的老年代单线程收集器。
		
		Parallel Old收集器：吞吐量优先收集器，是Parallel Scavenge的老年代版本，基于标记-整理算法的老年代多线程并发收集器。
		
		CMS（Concurrent Mark Sweep）收集器：并发低停顿收集器，是一种以最短停顿时间为目标的基于标记-清除算法实现的老年代收集器，目前很大一部分的互联网网站或者基于B/S架构的服务端，这类应用通常比较关注服务的响应速度，以给用户带来良好
			的用户体验，CMS收集器较适合。
			它的垃圾收集过程包括四个步骤：
				（1）初始标记（initial mark），只是标记一下GC Roots能直接关联到的对象，速度很快。
				（2）并发标记（concurrent mark），从GC Roots的直接关联对象开始遍历整个对象树的过程，这个过程耗时但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
				（3）重新标记（remark），修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个时间会比初始标记稍长一点，但是也很短。
				（4）并发清除（concurrent sweep），清理掉标记阶段标记的死亡对象，由于不需要移动对象，所以这个阶段可以与用户进程并发进行，不会产生STW。
				其中初始标记、重新标记仍然需要STW，但是消耗时间很短，所以从总体上看，CMS的内存收集过程几乎是与用户线程并发进行的。
			缺点：
				（1）无法处理浮动垃圾（并发运行的程序在垃圾收集标记后重新产生的垃圾对象），需要预留空间，不能实现老年代满了再收集（默认有一百分比，达到此值就会触发CMS收集）。
				（2）标记-清除算法产生大量空间碎片，当没有足够的连续空间来分配大对象时，就会提前触发一次Full GC。有对应参数可适当解决。
				
		G1（Garbage First）收集器：jdk9之后取代了Parallel Scavenge/Paralled Old组合，成为服务端的默认垃圾收集器。
8.springmvc
	https://blog.csdn.net/a745233700/article/details/80963758

9.spring
	https://blog.csdn.net/a745233700/article/details/80959716

10.mybatis
	https://blog.csdn.net/a745233700/article/details/80977133

11.网络协议/IO
	OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
	TCP/IP模型：应用层（telnet、http、ftp、smtp等协议）、传输层（tcp、udp等协议）、网络层（ip协议等）、链路层。

	Linux内核IO模型：
		同步：
			阻塞IO（BIO）、非阻塞IO（NIO）、IO多路复用、信号驱动。
		异步：
			异步IO。
	telnet localhost 8080
	
	对称加密与非对称加密区别：
		https://blog.csdn.net/qq_29689487/article/details/81634057	

	http与https区别：
		https://www.cnblogs.com/wqhwe/p/5407468.html
	
12.java并发编程
	创建线程的三种方式，继承Thread类、实现Runnable接口、实现Callable接口。
	想要拿到线程执行的返回结果，可以实现Callable<T>接口，内部使用call()方法执行线程逻辑。

	start() 线程级别调用，线程开启
	run() 方法级别调用，线程逻辑运行

	线程池：	https://www.jianshu.com/p/125ccf0046f3
	线程池ThreadPoolExecutor工作原理：
		当一个并发任务提交给线程池，先判断核心线程池所有线程是否都在执行任务，如果不是，则创建一个线程执行刚提交的任务。
		如果核心线程池已满，判断线程阻塞队列是否已满，如果未满，则将任务存储在队列中。
		如果队列已满，判断最大线程池是否已满，如果未满则创建新的线程执行当前任务，否则按照线程池饱和策略进行处理。
	线程池构造参数说明：
		corePoolSize：表示核心线程池大小。
		maximumPoolSize：最大线程池大小。
		keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了核心线程池大小，并且线程空闲时间超过了
			线程存活时间，这些线程将会被销毁，这样尽可能降低系统资源消耗。
		unit：keepAlive时间单位。
		workQueue：用于保存任务的阻塞队列。分类：ArrayBlockingQueue，数组实现的有界阻塞队列。
			LinkedBlockingQueue，链表实现的有界阻塞队列。PriorityBlockingQueue，支持优先级的无解阻塞队列。
		threadFactory：创建线程的工厂类。
		handler：饱和策略。当阻塞队列已满并且线程均已开启，说明线程池已经处于饱和状态。
			分类：AbortPolicy：直接拒绝所有提价的任务，并抛出异常。CallerRunsPolicy：只用调用者所在的线程来执行任务。
			DiscardPolicy：不处理直接丢弃掉任务。DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。
	线程执行submit与execute的区别：
		可接收的任务类型：
			execute只能接收Runnable类型的任务。submit可以接收Runnable和Callable类型的任务。
		返回值：
			execute没有返回值。submit有返回值，通过返回的Future对象的get()方法获取线程执行结果。
		异常处理：
			execute可以对异常进行正常捕获。submit如果不使用get()方法获取返回结果，会吃掉异常。

13.Kafka
	结构：
	zookeeper集群 --> 多个Kafka实例、消息服务代理broker（消息生产者Producer生产消息，消息消费者Consumer订阅消费消息）
		--> 消息分类主题Topic 
		--> 分区Partition（解决单个Topic对应文件的IO性能瓶颈，通过增加水平扩展，可以分布在broker集群中不同的服务器上。
			Kafka引入了分区多副本机制Replica，提升服务容灾能力，副本之间是“一主多从”的关系，leader副本负责读写请求，follower副本负责副本间消息同步。
			消息在到达分区时会被分配一个特定的偏移量offset，offset是消息在分区中的唯一标识，保证消息在分区内的顺序性，offset不跨越分区，就是说Kafka保证的是分区有序而不是主题有序。）

14.Zookeeper
	开源的分布式协调服务，具有四种类型的数据节点（Znode）：持久节点、临时节点、持久顺序节点（增加了由父节点维护的自增整数数字）、临时顺序节点。
	数据结构：数据模型结构与Unix文件系统类似，整体上可以看做一棵树，每个节点称为ZNode（默认能够存储1MB数据）。
	集群规则：2N+1，N>0。所以集群至少要有3个节点，且是单节点，集群中半数以上的节点存活集群才可用。
	应用场景：实现数据发布/订阅、负载均衡、命名服务（对服务进行命名，便于识别）、统一配置管理、分布式协调/通知、集群管理（通过将节点信息写入Znode，监控Znode获取节点状态变化）、
		Master选举、分布式锁（临时节点）、分布式队列。

15.Dubbo
	http://dubbo.apache.org/zh-cn/docs/user/quick-start.html
	分布式治理的服务框架，解决各服务之间的依赖和调用关系（SOA面向服务的架构体系）。默认使用netty通信框架。Dubbo是基于NIO实现的非阻塞并行调用，客户端不需要
		启用多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个Future对象。
	结构包含：
		注册中心（register）：一般使用zookeeper作为注册中心。
		服务提供者（provider）：提供接口服务的应用。
		服务消费者（consumer）：远程调用服务接口的应用。
		监控中心（monitor）：
		提供者容器（container）：
	服务失效踢出是基于zookeeper的临时节点原理。
	服务提供者可以使用@Service注解将提供服务的接口注册入注册中心，服务消费者可以使用@Reference注解远程调用服务。
	配置覆盖策略，可以使用java -Ddubbo.protocol.port=20880方式覆盖。配置使用优先级，外部java -jar命令加参数方式 > application.properties > dubboo.properties（一般放置公共配置）
	常用配置：	
		启动时检查：会在应用启动时检查消费者依赖的服务是否可用，不可用时就会抛出异常，导致启动失败。默认check="true"。如果spring容器是懒加载的，则需要关闭检查：dobbo:consumer中设置check="false"。
		超时配置：默认1000，即1秒。dubbo:reference中配置timeout="3000"。配置覆盖关系：方法级优先，接口级次之，全局配置再次之。级别相同时，消费方优先，提供者次之。
		重试次数：接口调用失败后（如超时）会引发重试（可能会重试其他服务节点）。dubbo:reference中配置retries="3"（在幂等接口如查询、删除、部分修改上设置）。
		多版本：当接口出现不兼容时，其多个实现可以用版本号过渡，版本号不同的服务接口相互间不引用。可用于新功能过渡上线（灰度发布）。dubbo:interface中配置version="1.0.0"。
		本地存根：服务提供者在被服务消费者调用之前先对其服务消费方执行部分逻辑，如参数验证、做缓存等。可以在消费方写接口本地存根，需要实现对应远程接口，需要实现有参构造器在实现类中
			做预处理，符合条件才会生成远程代理对象。dubbo:reference中配置stub="本地存根实现类的全类名"
			
		spring boot方式dubbo具体配置可以在主类上使用@ImportResource(loactions="classpath:provider.xml")方式引入配置文件。或者通过配置类@Configuration方式。
	注册中心宕机后服务消费者也可以通过本地缓存来调用服务提供者接口。或者在@Reference中指定url方式直连服务提供者。
	负载均衡：
		基于权重的随机（Random）负载均衡机制。默认。请求分配比例大约占该节点权重占总权重的比例。
		轮询（RoundRobin）负载均衡机制。逐个节点请求。也可结合权重。
		最少活跃数（LastActive）负载均衡机制。哪台节点上一次请求耗时最少请求哪台节点。
		一致性hash（ConsistentHash）负载均衡机制。上次请求的是哪台节点这次就请求哪台。
	服务降级：
		当服务器压力剧增时，根据实际情况及流量，对一些服务有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作。措施：（1）强制返回为null；（2）调用失败后返回为null。
	集群容错：
		Failover：默认，失败后自动重试其它服务，适用于幂等调用。
		Failfast：快速失败，只发起一次调用，失败立即报错，适用于非幂等操作，如新增。
		Failsalf：失败安全，出现异常时，直接忽略。
		Failback：失败自动恢复，记录失败请求，定时重发。通常用于消息通知操作。
		ForKing：并行调用多个服务器，只要有一个成功即返回。
		Broadcast：广播调用所有提供者，逐一调用，任一报错则报错。
		
16.索引
	索引是排好序的数据结构，用于根据数据结构算法实现数据行的快速检索。
	常见数据结构：
		https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
		二叉树：树状结构，右边子元素大于父元素。缺点：对于单边增长的数据插入就会退化为链表（查询效率低）。
		红黑树：在二叉树的基础上优化了单边数据插入时的问题（平衡二叉树），自动平衡优化结构为树结构。缺点：数据量大时树的深度很大。
		B Tree：优化了红黑树深度缺点。B Tree每个节点包含多个索引（索引左右也是多索引节点二叉树），从左到右递增排列。页节点具有相同的深度，叶节点的指针为空。所有索引元素不重复。
			节点中的数据索引从左到右递增排列。
		B+Tree：整体结构与B Tree类似。区别：非叶子节点不存储数据，只存储索引，节点可以放置更多索引（可进行更大的水平扩展，减少层数，减少磁盘IO操作次数）。每个节点大概能够
			存放16KB大小的数据。
				叶子节点之间用双向指针连接，提高了区间访问的性能（这也是mysql提倡自增主键的原因，也可提升索引字段范围查找性能）。
		散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。
		
		MySQL的MyISAM引擎索引文件和数据文件是分离的（非聚集）。B+Tree非聚集索引的叶子节点存储的数据是数据行地址的指针。
			InnoDB引擎的数据文件与索引文件不分离（聚集，对应叶子节点可以获取整行数据，不用进行回表查询）。B+Tree聚集索引主键的叶子节点包含了索引所在行的所有字段数据。非主键字段的
			索引叶子节点只存储主键的值（节省空间），根据主键值再检索主键索引查找相应行记录。

	选择：
		B Tree索引：（1）适合高基数的字段（唯一值多）。（2）适合大量的增删改操作。	create index emp_dept_index on emp(dept_no) tablespace users;
		Bitmap(位图)索引：（1）适用于该列只有几个枚举的情况，如性别0，1。（2）更新代价很高。	create bitmap index emp_gender_index on emp(gender) tablesapce users;
		
	哈希索引：	create index index_test using hash on test(id); 适用于等值查询。
		底层是hash表，调用一次hash函数就可获取到相应的键值，之后进行回表查询出实际数据。
			进行等值查询速度更快，但无法进行范围查询。
			适合没有大量重复键值的列，哈希碰撞后查询效率很低。
	联合索引：多个字段同时建立一个索引。
		注意：在联合索引中想要命中索引，需要按照建立索引的字段顺序挨个使用，否则无法命中。
	未使用索引的情况：
		使用不等于查询；参与了函数运算； like时左边是通配符；联合索引时前面一个索引字段为范围查询。
17.Redis
	支持的5种数据类型：string、list（底层双向链表）、set、zset（通过score排序）、hash。
	支持master-slave模式的数据备份。
	redis的所有单个操作都是原子性的，多个操作支持事务，也能控制操作的原子性。
	redis是单进程单线程的，利用队列技术将并发访问变为串行访问。
	一个字符串能存储的最大容量为512MB。
	redis的两种持久化方式：
		https://www.cnblogs.com/shizhengwen/p/9283973.html

		一、RDB：使用数据集快照的方式持久化数据，粒度较大。在某个时间点记录redis的所有键值对，将数据写入一个临时文件（dump.rdb）替换上次持久化的文件，加载数据库时恢复数据到内存。
		过程：fork一个进程，遍历hash table，利用copy on write，把整个dump.rdb保存下来。save、shutdown、slave命令会触发这个操作。
		优点：（1）容灾性好，持久化文件可以保存到安全的磁盘。（2）性能最大化，使用单独fork子进程完成持久化写操作，让主进程继续处理命令，保证IO最大化。
			（3）相对于较大的数据集，比AOF的启动效率更高。
		缺点：（1）缓存一致性较低，RDB方式是间隔一段时间进行内存数据持久化，如果在下一次持久化之前redis发生故障（或手动关闭），可能会造成数据丢失。

		二、AOF：把写操作指令，持续的写入aof文件中。
		优点：（1）缓存一致性高，每进行一次写操作就记录到aof文件中。
		缺点：（1）AOF文件相对较大，且恢复速度慢。
		选择的标准：如果愿意牺牲一些性能，换取更高的缓存一致性，则使用aof方式。
	常见的性能问题和解决方案：
		（1）Master最好不要写内存快照，写内存快照时save命令调度rdbSave函数会阻塞主线程的工作，当快照较大时对性能影响是非常大的，会间断性停止服务。
		（2）为了主从复制的速度和连接的稳定性，Master和Slave最好在一个局域网内。
		（3）尽量避免在压力比较大的主库上添加从。
	redis同步机制：
		redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到从节点，从节点
		接收完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到从节点进行重放就完成了同步过程。
	主从复制（redis sentinel），用于实现高可用，在master宕机时会自动将slave提升为主节点，继续提供服务。
	集群（redis cluster），用于实现扩展性，集群中各几点分配16384个哈希槽。在单个redis内存不足时，使用redis cluster进行分片存储。
	什么情况下集群不可用？集群中任一主节点不可用并且其没有相应从节点顶上，则整个集群就会不可用。
	集群中哈希槽的概念？redis集群中有16384个哈希槽，每个key通过CRC校验后对18384取模来决定放置在哪个哈希槽，集群中的每一个节点负责一部分哈希槽。
	redis事务相关的命令：
		multi、exec、discard、watch	
	如何将一些固定已知前缀的key全部找出来？使用keys指令扫描指定模式的key列表。由于redis是单线程的，keys操作会导致线程阻塞一段时间，线上服务会停顿，知道指令执行完毕，
		服务才会恢复。这个时候可以使用scan指定，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，可以在代码中进行手动去重。
	redis做异步队列怎么用？一般使用list结构作为队列，lpush入队生产消息，rpop出队消费消息（非阻塞模式）。当rpop没有消息时，适当sleep一会再重试。如果不用sleep，可以使用
		阻塞模式的消息队列，使用brpop出队，返回0表示处于阻塞状态。
	redis如何实现一对多消费？可以使用pub/sub发布订阅模式（chanel），实现1:N消息队列。
	redis如何实现延时队列？使用zset有序集合，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取n秒之前的数据轮询进行处理。
	redis如何实现分布式锁？使用setnx指令来争抢锁的同时设置过期时间，保证是一个原子性操作。使用del指令来释放锁，也要保证是原子操作。

18.MySQL
	mysql的5中引擎：ISAM、MyISAM、Heap、Merge、InnoDB。
	MyISAM和InnovationDB区别：
		MyISAM不支持事务，但是每次查询都是原子的。支持表级锁，每个操作都是对表加锁。一个MyISAM表对应三个文件：表结构文件、数据文件、索引文件。
			采用非聚集索引，索引文件的数据域指向数据文件的指针。
		InnoDB支持事务（ACID特性），支持事务的四种隔离级别（解决事务并发问题，脏读、不可重复读、幻读）。支持行级锁和外键约束，可以支持写并发。
			https://blog.csdn.net/weixin_42671172/article/details/106849808
			主键索引采用聚集索引（索引的数据域存储数据文件本身）。辅索引的数据域存储主键的值，因此从辅索引中查找数据需要先从索引中查找到主键
			值，再访问主索引根据主键值查找数据文件。最好使用自增主键，防止维护B+树时结构的大调整。
	char和varchar的区别：char列长度固定为创建表时执行的长度，范围是1到255，当char被存储时，用空格填充到指定长度，检索char需要删除尾随空格。char的查询速度
		要比varchar快，因为还要对varchar进行语法分析，确定这个字段是多少位的。
		varchar是可变长度字符串，不管初始时预分配字段长度为多少，存储时长度与实际字符串长度一致。
	BLOB和TEXT区别：
		BLOB是一个二进制对象，可以容纳可变数量的数据，区分大小写。而TEXT不区分大小写。
	分页查询：select * from table_name where limit 10,30;
	now()函数和current_date()区别：now()显示当前年份，精确到秒。current_date()显示年份精确到日。
	mysql中非标准字符串类型：tinytext、text、mediumtext、longtext。
	mysql支持事务吗？在InnoDB引擎下关闭自动提交，使用set autocommit = 0，就需要我们手动提交或回滚更改的操作。
	
	联合索引的最左前缀匹配原则：mysql会一直按照建立的索引顺序从左向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，那么在右边的索引查询条件则不会生效。
		比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
		=可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
		
	建立索引的原则：（1）在频繁使用的、对于缩小查询范围有很大帮助的字段建立索引。（2）在需要排序的字段上建立索引。（3）查询中与其他表关联的外键字段建立索引。
		（4）统计或者分组的字段；
	什么情况下不适合建索引？（1）表记录较少。（2）查询中很少涉及的列或重复值比较多的列不宜建立索引。（3）经常增、删、改的表（更改数据时还要维护索引文件，增加了IO负担）。
	（4）特殊的数据类型不宜建立索引，如text等。
	什么情况下设置了索引但无法使用？（1）对于like语句，以"%"或者"_"开头不会使用索引，结尾会使用索引。（2）or的前后没有同时使用索引。（3）不满足最左前缀匹配原则。
		（4）对索引列进行了函数计算。（5）使用不等于时无法使用索引。（6）is not null无法使用索引，is null可以。
	innerDB为什么使用B+tree作为索引：只有叶子节点存储数据，树的深度低，支持范围查找、排序查找、分组查找、去重查找。
	查看mysql是否用到索引：explain select ...
	mysql索引类型：
		1.普通索引 create index index_name on table_name(col(length));	//字符串类型才能执行索引长度
		2.唯一索引 索引的值必须唯一，允许有空值。create unique index_name on table_name(col(length));
		3.主键索引 一般是在建表时同时创建主键索引。primary key ('id')
		4.组合索引 多个字段上创建的索引，查询条件使用了第一个字段时索引才会被使用，同时服务最左前缀原则。create index index_name on table_name(col1,,col2,col3);
		5.全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值比较，配合match、against使用，只能在char、varchar、text上创建全文索引。create fulltext index index_name on table_name(content);
	
	事物的并发问题：
		（1）脏读：事务A读取了事务B更新的数据，然后B执行了回滚操作，那么A读到的数据是脏数据。
		（2）不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对事务进行了更新并提交，导致事务A在多次读取同一数据时结果不一致。
		（3）幻读：举例，系统管理员A将数据库中的所有学生成绩由具体分数改成ABCDE等级，但是系统管理员B在此时插入了一条具体分数的记录，当A更改结束后发现还有一条
			记录没有更改过来，就像发生了幻觉一样，就叫幻读；
		总结：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读问题只需锁住操作行，解决幻读需要锁表。
	
	事务的隔离级别：
		读未提交：一个事务可以读取另一个事务未提交的数据。
		读提交（sql server和oracle默认）：一个事务要等另一个事务提交后才能读取数据。写数据会锁住相应的行，可以解决脏读。
		可重复读（mysql默认）：开始允许读取数据时（事务开启），不能再修改数据。可以解决脏读、不可重复读。
		串行化：事务串行化顺序执行。读写都会锁住整张表，解决所有事务并发问题。
		
		隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大
	
	表的连接：
		内连接：分为等值连接和自然连接。
			等值连接只要满足给定条件即可。select collist from table1,table2 where col2 = 条件;
			自然连接选取两个表中相匹配的数据。select collist from table1 inner join table2 on table1.col = table2.col;
		外连接：内连接保证两张表中所有行都满足条件，外连接不仅包含符合条件的行，还包括左表（左外连接）、右表（右外连接）、两个表（全外连接）中所有数据行。
				select collist from table1 left/right outer join table2 on table1.col = table2.col;		（mysql8.0不支持全外连接） 
				
	调用存储过程：statementType="CALLABLE" 执行sql：{call procedure_name(var1, var2...)}
	
	MVCC：数据库多版本并发控制，只要是为了提高并发的读写性能，不加锁就能实现多个事务并发读写。
		有两种读方式：快照读：普通的select是快照读。当前读：插入、删除、更新属于当前读，需要加锁，符合两阶段锁协议。
	
	数据库优化相关：
		（1）设计良好的数据结构，允许部分数据冗余，尽量避免连接查询。
		（2）选择合适的存储引擎和表字段类型，适当的添加索引。
		（3）数据库主从读写分离（主库负责写，从库负责读）https://blog.csdn.net/why15732625998/article/details/80463041。
		（4）对表进行逻辑分割，减少单表数据量提高查询速度。
		（5）添加缓存机制。
		（6）使用连接代替子查询。
		（7）尽量不使用*号，要转化为具体的列需要查数据字典，比较耗时。
		（8）where子句规则，oracle中where子句中的条件是从右往左处理的，表之间的连接最好写在其它条件之前，能过滤掉大量数据的条件最好写在where子句的末尾。
		（9）使用exits、not exits替代in、not in，在子查询中，in子句将执行一个内部的排序与合并，对子查询表执行了全表遍历。
		（10）尽量批量处理，降低事务操作次数。
		（11）将字段很多的表分解为多个表。

19.并发编程
	进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位。一个程序最少一个进程，一个进程最少一个线程。
	什么是线程的上下文切换？多线程会共同使用计算机上的一组CPU，而线程数大于给程序分配的CPU数量时，为了使各个线程都有执行的机会，就需要切换使用CPU资源，就是线程的上下文切换。
	为什么使用Executor线程池？每次执行任务创建单个线程new Thread()是比较耗时、耗资源的，而且缺乏管理（定时定期执行不便实现），可以被无限制的创建，线程之间的相互竞争会导致过
		多占用系统资源而导致系统的瘫痪。
	Executors是创建线程池的工具类。Executor接口用于执行线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法操作线程池。
		使用ThreadPoolExecutor可以创建自定义线程池。Future对表示异步处理的结果，提供了检查处理是否完成的方法，并使用get()方法获取线程执行结果。
	什么是原子操作？原子操作意为不可中断的一个或一系列操作，是一个不受其它操作影响的操作任务单元。原子操作是多线程环境下避免数据不一致的必要手段。i++并不是一个原子操作。
	常见的原子类：java.util.current包下提供了一组原子类，其基本特性就是在多线程环境下，当有多个线程同时执行这些类的方法时，具有排他性。即当某个线程进入方法，执行其中的
			指令时，不会被其它线程打断，别的线程就像自旋锁一样，一直等到该方法执行完成。原子类：AtomicBoolean、AtomicInteger、AtomicReference。
			原子数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。
			解决ABA问题的原子类：AtomicMarkableReference（通过引入boolean来反映有没有被改变过）、AtomicStampedReference（通过引入int累加来反映有没有被改变过）。
	Lock接口是什么？Lock接口是Synchronized的扩展版，比同步方法和同步块提供了更具扩展性的锁操作。
	什么是多线程的上下文切换？是指CPU控制权由一个已经正在运行的线程切换到另一个就绪并等待获取CPU执行权的线程的过程。
	线程的5种状态：
		新建状态（New）：用new 语句新建的线程处于新建状态，此时它和其它Java对象一样，仅在堆中被分配了内存。
		就绪状态（Runnable）：当一个线程对象被创建后，其它线程调用该线程的start()方法，该线程就处于就绪状态。Java虚拟机为它创建方法调用栈和程序计数器。
			处于这个状态的线程位于可运行池中，等待CPU的使用权。
		运行状态（Running）：线程占用CPU，执行程序代码，只有处于就绪状态的线程才能转为运行状态。
		阻塞状态（Blocked）：阻塞状态是线程因为某些原因放弃CPU，暂时停止运行。线程处于阻塞状态时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转为运行状态。
		死亡状态（Dead）：当线程退出run()方法时，就进入死亡状态，该线程结束生命周期。
	volatile作用？保证内存可见性（当线程修改了主内存变量其它线程可以感知到）和禁止指令重排，但它不能保证原子性。
	wait()、yield()和sleep()方法的不同？最大的不同是在等待时wait会释放锁，而sleep会一直持有锁。wait通常用于线程交互，sleep通常用于暂停执行。wait方法会释放cpu执行权和
		占有的锁。sleep方法仅释放cpu使用权，锁仍然占用。线程被放入超时等待队列，与yield相比，它使线程较长时间得不到执行。yield方法仅释放cpu使用权，锁仍然占用，线程会
		被放入就绪队列，会在短时间内再次执行。
	直接调用线程的run()方法只是在当前线程中执行该方法，相当于调用普通方法，想要在线程中执行需要调用Thread.start()。
	并发编程三要素：（1）原子性，是指一个或多个操作，要么全部执行并且在执行的过程中不被其它操作打断，要么全部不执行。
			（2）可见性，指多个线程对变量进行修改后，其它线程可以立即看到修改的结果。（3）有序性，即程序的执行顺序按照代码的先后顺序来执行。
	实现可见性的方式？synchronized或者Lock，保证同一时刻只有一个线程获取锁执行代码，锁释放之后将最新的值刷新到主内存，其它线程可见。
	
20.Java内存模型JMM
	JMM中的原子操作：
		read（读取）：从主内存中读取数据。
		load（载入）：将主内存中读取到的数据写入工作内存。
		use（使用）：线程从工作内存读取数据进行计算。
		assign（赋值）：将计算好的值重新赋值到工作内存中。
		store（存储）：将工作内存数据写入主内存。
		write（写入）：将store到主内存中的变量赋值给主内存中的变量。
		lock（锁定）：将主内存变量加锁，标识为线程独占状态。
		unlock（解锁）：将主内存变量解锁，解锁后其他线程可以锁定该变量。
	多线程操作共享变量时，每个线程会将主内存中的共享变量复制一份作为工作内存中的共享变量副本（JMM控制），当一个线程对共享变量副本进行修改后，其他线程是感知不到的。此时我们可以
		在共享变量上加上volatile关键字，保证了共享变量在多个线程之间的相互可见性。
		volatile是基于MESI缓存一致性协议实现：当多个CPU从主内存中读取数据到各自的高速缓存，当其中某个CPU修改了缓存中的数据，该数据会马上同步到主内存，，其他CPU通过总线嗅探机制
			可以感知到数据的变化从而将自己缓存中的该数据失效，需要继续使用变量时会重新read该数据。底层实现主要是通过汇编语言的lock指令，会将当前处理器缓存行的数据锁定并立即写回
			到主内存，这个写内存的操作会引起在其他CPU里缓存了该内存地址的数据无效（MESI协议）。
	并发编程的三大特性：可见性、原子性、有序性。
	volatile保证了可见性和有序性（防止CPU指令重排序），不能保证多个操作的原子性，就可能产生多线程的操作丢失问题。保证原子性需要借助synchronized这样的悲观锁实现。
		
21.Docker
	进入容器：docker exec -it 容器id bin/bash
	退出容器：exit
	
	K8S（Kubernetes）,容器化集群管理系统。
		功能：
			自动装箱：基于应用运行环境资源配置自动部署应用容器。
			自动修复：当容器异常时，自动对容器进行重启。
			水平扩展：通过简单的命令，对应用容器规模进行扩大或裁剪。
			服务发现：具有服务发现和负载均衡能力。
			版本回退：历史版本即时回退。
	
22.java基础
	匿名内部类是否可以继承其它类和实现接口？可以。在Android开发中常用来实现时间监听和回调。一个内部类对象可以访问创建它的所有外部对象的成员，包括私有成员。
	final修饰符用法？修饰类，表示类不能被继承；修饰方法，表示方法不能被重写；修饰变量，表示变量在赋值后不能被更改（常量）。
	集合：在for遍历集合的时候是不能对集合进行remove操作的，这样会改变集合大小从而造成结果不准确甚至数组下标越界。如果要边遍历边remove，必须使用iterator。
		ArrayList：非线程安全，底层基于数组实现容量大小动态变化，默认大小为10，是在第一次添加元素才分配这个空间，允许null值。实现了List、RandomAccess、Cloneable、
			Serializable接口，所以支持快速访问、克隆、序列化。扩容机制首先扩充为原始容量的1.5倍。扩容后是通过数组元素的拷贝来确保元素的准确性，所以尽量减少扩容，初始化时给定初始大小。
		Vector：线程安全，和ArrayList继承同样的接口，具有相同的特性，默认扩展因子为1倍，因为使用了synchronized修饰，效率较ArrayList低。
			Vector和ArrayList都是以数组方式存储元素，允许按序号索引元素，但是插入元素设计元素移动等内存操作，所以索引数据快而插入速度慢。
		LinkList：基于双向循环链表设计的，可以被当做堆栈、队列、双端队列进行操作。检索速度较慢，插入速度较快。
	a = a+b和a += b的区别：+= 操作隐式地将加操作的结果类型转换为持有结果地类型。
	3*0.1 == 0.3 返回true还是false？返回false，浮点数不能完全精确地标识出来。
		
23：数据结构
	链表：是由一系列非连续的节点组成的数据结构，将内存中的数据单元通过附加的引用关联起来。分类：
		单向链表：通过每个结点的指针指向下一个节点从而链起来的结构，节点包含element（节点数据）、next（下一个结点的地址指针）。最后一个结点tail的next指向null。
		单向循环链表：与单向链表不同的是最后一个结点的next指向的是head结点。
		双向链表：包含两个指针，per指向前一个结点，next指向后一个节点。第一个节点head的pre指向null，最后一个节点tail的next指向null。
		双向循环链表：第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。
	
24.
			
	
开发思路
	（1）确定需求；（2）分析可行性；（3）确定技术方案；（4）设计表及字段；（5）业务开发；
	数据结构与算法、计算机组成原理、操作系统、C语言、计算机网络等
	
	需求过来之后拿到原型图，讨论需求，我们后端去驱动前端具体讨论怎么做，确定大致的思路、实现方案（技术）、开发周期什么的。简单的业务需求的话，先确定好需要的表和一些基础的
		字段，然后就开始开发，不懂的需求要及时反馈、更正，后面再逐步进行完善。复杂的业务需求的话就要设计具体的流程了。
	
工作内容：
	统一消息平台：
		我主要做的是开发了系统中的大部分消息网关接口，也就是对接第三方消息厂商，有短信（阿里云、联通）接口、企业微信、邮件、系统（公司门户），这些接口
		是系统内部调用，是可选可配的。对外的接口开发设计也有参与，有发送人学工号、消息类型、消息内容、消息链接等的参数。
		系统中的一些页面的增删改查，比如角色管理、用户、组织树等。
		
		关于对外接口限流：
			这个不是我做的，我看了代码，大概是：使用了自定义注解包含限制访问次数limit和时间范围sec两个属性 + 处理器拦截器（继承HandlerInterceptor）中获取包含了
				自定义注解的处理器方法,然后根据注解设置的属性值操作redis设置一个过期时间的key，每调用一次将其加1（这个操作要保证原子操作），超过最大限制次数时禁止调用并通知业务系统管理员。
		
		关于接口调用权限：访问接口需要获取token，有效期为1天。
		
		性能优化：
			发消息性能优化：
				一开始定位到消息发送较慢的点不是消息的生产阶段，而是消息的消费阶段。
				
					开启多线程消费消息，操作kafka的api设置并发消费分区消息，消费者数量小于等于主题的分区数。开启批量消息处理，对于消息内容相同的消息（消息实体的一个标识确定），将多个收件人
						合并发送，因为这些消息类型的厂商都支持批量发送。
					使用kafka的测试脚本，测试服务器环境的消息处理的最大性能的分区数，设置partition数量。增加单次消息抓取量，增加单次消息处理的超时时间。
					
			发送历史消息查询性能优化（大概有几百万条数据）：一开始是在消息查询条件上建立索引，后来发现效果不是特别显著。将历史消息分时间片进行展示，按月存储消息到不同的消息历史表。
	
		遇到的问题：
			短信模板不够灵活：短息消息后面由于对接了阿里云，因为消息需要按照模板来，发现系统的短信业务还是不够灵活，然后我们又增加了短信模板的配置，可以在发短信时选用。
			kafka频繁挂掉的问题：之前也排查了很久，最后发现是linux系统定时清理了kafka在/tmp下的日志文件，导致kafka生产与消费信息残缺从而进程宕掉。
			
	公共数据平台：
		这个系统主要做的是维护工作。数据接口服务页面开发，维护发布出去的消息接口。配置接口页面的新增数据内容分类等。
		
	统一身份认证：
		开发了企业微信移动端认证同步功能，用户手动将认证的用户信息注册到企业微信。
		认证实现QQ、微信免登。
		
	学工系统：
		在线考试功能开发：教师端教职工和以维护题目
		 
			








